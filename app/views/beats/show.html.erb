
<%= link_to 'Edit', edit_beat_path(@beat) %> |
<%= link_to 'Back', beats_path %>

<canvas id="display"></canvas>
<label id="open-file">
    音楽ファイルを開く
    <input id="file-input" type="file" accept="audio/*">
  </label>

<canvas id="mycanvas"></canvas>

<script src="https://cdn.jsdelivr.net/gh/phinajs/phina.js@v0.2.3/build/phina.js"></script>

<script>
  if (!phina.util.Support.webAudio) {
    alert('webAudioに対応していません！最新のブラウザを使って下さい！');
  }

  phina.globalize();
</script>

<script>

var SCREEN_WIDTH = 1024;
var SCREEN_HEIGHT = 768;
var MARKER_RADIUS = 30; //ノーツの大きさ
var MARKER_STROKE_WIDTH = 5; //ノーツの幅

var MARKER_APPEARANCE_DELTA = 3000; // ノーツ出現時間(ms): 大きくするほど低速
var MUSIC_START_DELAY = 2000;

// var TRACK_NUM = 9;
// var ICON_INTERVAL_DEGREE = 180 / (TRACK_NUM - 1); // 22.5
// var UNIT_ARRANGE_RADIUS = SCREEN_WIDTH * 0.41 | 0;


var RATING_TABLE = {
  perfect: {
    score: 1000,
    range: 34, //ms
  },
  great: {
    score: 500,
    range: 64, //ms
  },
  good: {
    score: 100,
    range: 90, //ms
  },
  miss: {
    score: 0,
    range: 134, //ms
  },
};


var ASSETS = {
  sound: {
    music: "<%= asset_path("energy.mp3") %>",
    ring: "<%= asset_path("tamborine.mp3") %>",
  },
  json: {
    beatmap: "<%= asset_path("notes.json") %>"
  },
  image: {
    'bg': "<%= asset_path("club.png") %>"
  }
};



/**
 * タイトル
 */
phina.define('TitleScene', {
  superClass: 'phina.display.DisplayScene',

  init: function(params) {
    this.superInit(params);
    this.backgroundColor = params.backgroundColor;
    Sprite('bg').addChildTo(this)
            .setPosition(this.gridX.center(), this.gridY.center());


    // タイトルラベル
    Label({
      text: "<%= @beat.title %>",
      fill: "white",
      stroke: "#2F3CEC",
      strokeWidth: 6,
      fontSize: 80,
    })
    .setPosition(this.gridX.center(), this.gridY.span(6))
    .addChildTo(this)

    var touchLabel = Label({
      text: "タップでSTART",
      fill: "white",
      stroke: "#2F3CEC",
      strokeWidth: 6,
      fontSize: 44,
    })
    .setPosition(this.gridX.center(), this.gridY.span(12))
    .addChildTo(this);

    // 明滅させる
    touchLabel.tweener.clear()
    .setLoop(true)
    .to({alpha: 0}, 700)
    .to({alpha: 1}, 700)
    ;

    // モバイルでの再生制限アンロックのため、画面タッチ時にSoundを無音再生
    this.on('enter', function() {
      var event = "touchstart";
      var dom = this.app.domElement;
      dom.addEventListener(event, (function() {
        return function f() {
          var context = phina.asset.Sound.getAudioContext();
          var buf = context.createBuffer(1, 1, 22050);
          var src = context.createBufferSource();
          src.buffer = buf;
          src.connect(context.destination);
          src.start(0);

          dom.removeEventListener(event, f, false);
        }
      }()), false);

      // シーン遷移
      this.on('pointend', function() {
        this.exit();
      });
    });

  },

});

/*
 * ユニット表示アイコン
 */
phina.define('UnitIcon', {
  superClass: 'phina.display.CircleShape',

  init: function(id, label) {
    this.superInit({
      radius: MARKER_RADIUS,
      strokeWidth: MARKER_STROKE_WIDTH,
      stroke: "rgba(127, 255, 255, 1)",
      fill: "rgba(127, 255, 255, 0.4)",
    });
    this.setInteractive(true);
    this.id = id;
  },

  fireEffect: function() {
    EffectWave().addChildTo(this);
  },

});


/**
 * ターゲットマーカー（ノーツ）
 */
phina.define('TargetMarker', {
  superClass: 'phina.display.CircleShape',

  init: function(targetTime, trackId, type) {
    this.superInit({
      radius: MARKER_RADIUS,
      strokeWidth: MARKER_STROKE_WIDTH,
      stroke: "magenta",
      fill: false,
    });

    this.visible = false;
    this.scaleX = this.scaleY = 0;
    this.isAwake = true;

    this.targetTime = targetTime;
    this.trackId = trackId;

    // 進行方向 右→左
    this.vector = phina.geom.Vector2(
      Math.cos((180).toRadian()),
      Math.sin((180).toRadian())
    );
  },
});


/**
 * エフェクト：白フェードアウト円
 */
phina.define('EffectWave', {
  superClass: 'phina.display.CircleShape',

  init: function(options) {
    this.superInit({
      radius: MARKER_RADIUS,
      stroke: false,
      fill: "white",
    });

    this.tweener
    .to({scaleX:2, scaleY:2, alpha:0}, 250)
    .call(function() {
      this.remove();
    }, this);
  },
});

/**
 * エフェクト："PERFECT!"など
 */
phina.define('RateLabel', {
  superClass: 'phina.display.Label',

  init: function(textParam) {
    this.superInit({
      text: textParam.text,
      fontSize: 40,
      strokeWidth: 4,
      fill: "magenta",
      stroke: "white",
    });

    this.tweener
    .set({scaleX: 0.2, scaleY: 0.2, alpha: 0})
    .to({scaleX:1, scaleY:1, alpha:1}, 130, "easeOutCirc")
    .wait(250)
    .to({alpha:0}, 100)
    .call(function() {
      this.remove();
    }, this);
  },
});

/**
 * メイン
 */
phina.define('MainScene', {
  superClass: 'DisplayScene',

  init: function(options) {
    this.superInit(options);
    this.backgroundColor = "navy";
    // 背景
    Sprite('bg').addChildTo(this)
                .setPosition(this.gridX.center(), this.gridY.center());

    var self = this;
    var gx = this.gridX;
    var gy = this.gridY;
    var AM = phina.asset.AssetManager;

    var beatmap = AM.get('json', 'beatmap').data;

    // タイマーのセット
    this.elapsedTime = 0; // 経過時間
    this.gameTime = 0 - MUSIC_START_DELAY + beatmap.offset; // 判定用時間

    this.totalScore = 0;

    // 時間が来たら音楽流す
    this.one('musicstart', function() {
      SoundManager.playMusic('music', null, false);
    });

    // ユニットアイコンの配置（ノーツの出発地点）
    var iconGroup = DisplayElement()
    .setPosition(gx.center(12), gy.span(12))
    .addChildTo(this);

    // タップアイコンの配置（９個）→１個に変更
    // for (var i = 0; i < 1; i++) {
      // var label = INDEX_TO_KEY_MAP[i].toUpperCase(); // 対応キーを表示
      // var rad = (i * ICON_INTERVAL_DEGREE).toRadian(); // 度数をラジアン変換
      var icon = UnitIcon(0)
      .setPosition(
        gx.center(-26),
        gy.center(-8),
      )
      .addChildTo(iconGroup);

      // 加速度センサーを利用した判定機能
      window.addEventListener("devicemotion", function (event) {
        // 加速度センサーの値を変数に格納
        var x = Math.floor(event.accelerationIncludingGravity.x)
        var y = Math.floor(event.accelerationIncludingGravity.y)
        var z = Math.floor(event.accelerationIncludingGravity.z)

        if (Math.abs(x) > 15 || Math.abs(y) > 15 || Math.abs(z) > 15) {
          self.judge(icon);
        }
      })


      // タップ・クリック判定
      icon.onpointstart = function() {
        self.judge(this); // 自分を渡す
        this.flare('dm'); //dm発火
      };


    // 譜面の展開
    this.markerGroup = DisplayElement()
    .setPosition(iconGroup.x, iconGroup.y)
    .addChildTo(this);
    beatmap.notes.forEach(function(note) {
      TargetMarker(note.targetTime, note.track)
      .addChildTo(self.markerGroup)
    })

    // score表示
    this.scoreLabel = Label({
      text: 0,
      textAlign: "center",
      stroke: "magenta",
      fill: "white",
      strokeWidth: 2,
      fontSize: 30,
    })
    .setPosition(gx.center(), gy.span(3))
    .addChildTo(this)
    .on('enterframe', function() {
      this.text = self.totalScore;
    });

    // リセットボタン
    // Button({
    //   text: 'RESET',
    //   fill: "#F539B9",
    // })
    // .setOrigin(1, 0)
    // .setPosition(this.width, 0)
    // .addChildTo(this)
    // .on('push', function() {
    //   SoundManager.stopMusic();
    //   self.exit('main')
    // });

  },

  update: function(app) {
    var self = this;
    var ps = app.pointers;
    var kb = app.keyboard;

    // タイマー加算
    this.elapsedTime += app.deltaTime;
    this.gameTime += app.deltaTime;

    // ゲームスタートまでの猶予
    if (this.has('musicstart') && this.elapsedTime > MUSIC_START_DELAY) {
      this.flare('musicstart');
    }

    // ゲーム終了（Scoreページ）
    if (this.elapsedTime > "<%= @beat.url%>") {
      SoundManager.stopMusic();
      self.exit({score:this.totalScore,message:'いいビートだっ！！！'});
    };

    // ノーツ描画
    var markers = this.markerGroup.children;
    markers.forEach(function(m) {
      if (!m.isAwake) return;

      var time = this.gameTime
      var rTime = m.targetTime - time; // 相対時間

      if (rTime < MARKER_APPEARANCE_DELTA) {
        // ノーツの位置比率や縮小率（倍率）を計算する
        // ratioはアイコンに近いほど1.0に近づく
        var ratio = (time - (m.targetTime - MARKER_APPEARANCE_DELTA)) / MARKER_APPEARANCE_DELTA;
        var distance = 750 * ratio; // ノーツのストローク

        m.setVisible(true)
        .setPosition(
          m.vector.x * distance,
          m.vector.y * distance
        )
        // ノーツの大きさ（縮小率）
        .setScale(1, 1);
      }

      // miss判定
      if (RATING_TABLE["miss"].range < -rTime) {
        this.reaction(m, "miss");
      }
    }.bind(this));

  },

  // 判定処理 以下そのままでOK
  judge: function(unitIcon) {
    var time = this.gameTime;

    // 判定可能ノーツを探索
    var markers = this.markerGroup.children;
    markers.some(function(m) {
      if (!m.isAwake || m.trackId !== unitIcon.id) return;

      // ノーツが有効かつtrackIdが一致、かつ判定範囲内
      // 判定が狭い順に判定し、該当したらループ拔ける
      var delta = Math.abs(m.targetTime - time);
      if (delta <= RATING_TABLE["perfect"].range) {
        unitIcon.fireEffect();
        SoundManager.play('ring');
        this.reaction(m, "perfect");
        return true;
      }
      if (delta <= RATING_TABLE["great"].range) {
        unitIcon.fireEffect();
        SoundManager.play('ring');
        this.reaction(m, "great");
        return true;
      }
      if (delta <= RATING_TABLE["good"].range) {
        unitIcon.fireEffect();
        SoundManager.play('ring');
        this.reaction(m, "good");
        return true;
      }
      if (delta <= RATING_TABLE["miss"].range) {
        this.reaction(m, "miss");
        return true;
      }
    }.bind(this));

  },

  reaction: function(marker, rating) {
    // ノーツ不可視化
    marker.isAwake = false;
    marker.visible = false;

    RateLabel({text: rating.toUpperCase()})
    .setPosition(this.gridX.center(), this.gridY.center())
    .addChildTo(this);

    this.totalScore += RATING_TABLE[rating].score;
  },

});


</script>

<script>
  phina.main(function() {
    var app = GameApp({
      assets: ASSETS,
      width: 667, //スマホの縦
      // width: 1024, //デバッグ用
      height: 375, //スマホの横
      startLabel: 'title',
      backgroundColor: 'navy',
      title: 'サンプル',
      fps: 60,
      query: '#mycanvas',
      fit: false,
    });

    app.run();
  });



// オーディオスペクトラム
  const canvas = document.querySelector('#display');
const canvasContext = canvas.getContext('2d');
canvas.width = 500;
canvas.height = 500;

// 音楽ファイルをdataURLに変換する
// Promiseを返す
async function convertAudioFileToDataUrl(file) {
  const reader = new FileReader();

  const loadPromise = new Promise((resolve, reject) => {
    reader.onload = (event) => {
      resolve(event.target.result);
    };
  });

  reader.readAsDataURL(file);

  return loadPromise;
}

// canvasにスペクトラムを描画する
function render(spectrum) {
  // canvasの中心座標
  const center = { x: Math.round(canvas.width / 2), y: Math.round(canvas.height/2) };

  // canvasの幅を均等に割り振る
  // 円なので360度（2π）を分割する
  const barRad = 2 * Math.PI / spectrum.length;

  // 円の半径
  const innerRadius = 60;
  const outerRadius = 250;
  const diffRadius = outerRadius - innerRadius;

  // 前の描画を消す
  canvasContext.clearRect(0, 0, canvas.width, canvas.height);

  for(let i = 0; i < spectrum.length; i++) {
    // 色相を回転
    const barDegree = barRad * i * 180 / Math.PI;
    canvasContext.fillStyle = `hsl(${barDegree}, 80%, 60%)`;

    // バーの開始角度・終了角度を計算
    const startRad = barRad * i;
    const endRad = barRad * (i + 1);

    // バーの開始点・終了点を計算
    const startX = center.x + innerRadius * Math.cos(startRad);
    const startY = center.y + innerRadius * Math.sin(startRad);
    const endX = center.x + innerRadius * Math.cos(endRad);
    const endY = center.y + innerRadius * Math.sin(endRad);

    // 値からバーの長さを計算
    const normalizedSpectrum = spectrum[i] / 255; // 0.0から1.0までの値に変換する。最大255なので255で割ればいい
    const barRadius = normalizedSpectrum * diffRadius + innerRadius;

    // 描画開始
    canvasContext.beginPath();

    // まず円弧を描く
    canvasContext.arc(center.x, center.y, innerRadius, startRad, endRad);

    // 次にバーを描く
    // バーの半径から外円上の点を割り出し、
    // 内円から外円へ四角形を描く
    canvasContext.moveTo(startX, startY);
    canvasContext.lineTo(barRadius * Math.cos(startRad) + center.x, barRadius * Math.sin(startRad) + center.y);
    canvasContext.lineTo(barRadius * Math.cos(endRad) + center.x, barRadius * Math.sin(endRad) + center.y);
    canvasContext.lineTo(endX, endY);

    // 塗る
    canvasContext.fill();
  }
}

// ファイルが選択されたら
const fileInput = document.querySelector('#file-input');
// const fileInput.value = ASSETS.sound.music;
// function butotnClick(){
//     fileInput = ASSETS.sound.music;
// }
// let button = document.getElementById('display');
// button.addEventListener('click', butotnClick);

let audio = null;
let audioSource = null;
let intervalId = null;


fileInput.addEventListener('change', async (event) => {
  // Web Audio API周りの準備
  const audioContext = new AudioContext();
  const analyzerNode = audioContext.createAnalyser(); // 音分析ノード

  // 2回目以降のときは、前のオーディとタイマーを破棄してから処理にうつる
  if(audio) {
    audio.pause();
    audio.src = '';
  }

  if(audioSource) {
    audioSource.disconnect();
  }

  if(intervalId) {
    clearInterval(intervalId);
  }

  // FFTのウィンドウサイズ
  // 値は2の累乗（2, 4, 8, 16, 32, ...）
  analyzerNode.fftSize = 128;

  const file = fileInput.files[0];
  if(file) {
    // スペクトラムを保持するUint8Arrayを用意
    // サイズはfftSizeの半分（＝frequencyBinCount）
    const spectrumArray = new Uint8Array(analyzerNode.frequencyBinCount);

    // 選択されたファイルをdataURLにしてaudio要素に突っ込む
    audio = new Audio();
    audio.src = await convertAudioFileToDataUrl(file);

    // 選択ファイル -> 分析ノード -> 出力（スピーカー）
    // の順でつなぐ
    audioSource = audioContext.createMediaElementSource(audio);
    audioSource.connect(analyzerNode);
    analyzerNode.connect(audioContext.destination);

    // 定期的に値を見て描画する
    // requestAnimationFrameでもok
    intervalId = setInterval((event) => {
      // ノードから周波数データを取り出す
      analyzerNode.getByteFrequencyData(spectrumArray);

      // 描画する
      render(spectrumArray);
    }, 1/60);

    // 再生開始
    audio.play();
  }
});



</script>

